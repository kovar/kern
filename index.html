<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Scale Web Interface using KCP Protocol</title>
  <!-- Link to Montserrat font from Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Montserrat', sans-serif;
      margin: 0;
      padding: 1rem;
      background-color: #ffffff;
      color: #333333;
    }

    header {
      margin-bottom: 1rem;
      border-bottom: 2px solid #012D5D;
      padding-bottom: 0.5rem;
    }

    h1,
    h3 {
      color: #012D5D;
    }

    #liveReadout {
      background: #f2f2f2;
      color: #333333;
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1rem;
      font-size: 1.3rem;
    }

    #liveReadout strong {
      color: #012D5D;
    }

    #log {
      background: #eaeaea;
      color: #333333;
      padding: 0.5rem;
      height: 250px;
      overflow-y: scroll;
      font-family: monospace;
      border: 2px solid #012D5D;
      border-radius: 4px;
    }

    button,
    input[type="text"],
    input[type="number"] {
      font-family: 'Montserrat', sans-serif;
      padding: 0.5rem 1rem;
      margin: 0.3rem;
      font-size: 1rem;
      border: 1px solid #012D5D;
      border-radius: 4px;
      background-color: #ffffff;
      color: #012D5D;
      cursor: pointer;
      transition: background-color 0.2s, box-shadow 0.1s, color 0.1s;
      min-height: 2.5em;
    }

    button:hover {
      background-color: #012D5D;
      color: #ffffff;
    }

    button:active {
      color: #757575;
      /* Change text color when pressed */
      box-shadow: inset 0 0 5px rgba(1, 45, 93, 0.5);
    }

    input[type="text"],
    input[type="number"] {
      border: 1px solid #cccccc;
    }

    .command-panel {
      background-color: #f9f9f9;
      border: 2px solid #012D5D;
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1rem;
    }

    .command-group {
      margin-bottom: 1rem;
    }

    details {
      background: #f9f9f9;
      border: 2px solid #012D5D;
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1rem;
    }

    details summary {
      font-size: 1.1rem;
      font-weight: 700;
      color: #012D5D;
      cursor: pointer;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    table,
    th,
    td {
      border: 1px solid #cccccc;
    }

    th,
    td {
      padding: 0.5rem;
      text-align: left;
    }

    .instructions {
      margin-bottom: 1rem;
      background: #f2f2f2;
      color: #333333;
      padding: 1rem;
      border-radius: 8px;
    }

    .instructions ol {
      margin-left: 1rem;
    }

    .sampling-rate-group {
      margin-top: 0.5rem;
    }
  </style>
</head>

<body>
  <header>
    <h1>Scale Web Interface (KCP Protocol)</h1>
    <p>This web app communicates with a Kern scale using the KCP protocol.</p>
  </header>

  <div id="liveReadout">
    <strong>Live Read-Out:</strong>
    <span id="currentReading">No reading yet</span><br />
    <small id="currentTime"></small>
  </div>

  <div class="instructions">
    <h3>How to Use</h3>
    <ol>
      <li>Click "Connect to Scale" and select your serial port.</li>
      <li>Use the command buttons or the custom command field to send commands (e.g., "SI" for immediate reading).</li>
      <li>Optionally, set your desired sampling rate (in milliseconds) using the provided input (default is 1000 ms).
      </li>
      <li>To record data, click "Start Recording". Then click "Start Measurement". The app will poll the scale at the
        set sampling rate, updating the live read-out and recording readings.</li>
      <li>When finished, click "Stop Measurement" and then "Stop Recording & Download" to save the data as a CSV file.
      </li>
    </ol>
  </div>

  <div class="command-panel">
    <div class="command-group">
      <button id="connect">Connect to Scale</button>
      <button id="disconnect" disabled>Disconnect</button>
    </div>
    <div class="command-group">
      <label for="commandInput">Send Custom Command:</label>
      <input type="text" id="commandInput" placeholder="e.g. SI for immediate weight" />
      <button id="sendCmd" disabled>Send Command</button>
    </div>
    <div class="command-group">
      <h3>Common Commands</h3>
      <button class="cmd" data-cmd="T">Tare (T)</button>
      <button class="cmd" data-cmd="Z">Zero (Z)</button>
      <button class="cmd" data-cmd="SI">Immediate Reading (SI)</button>
    </div>
    <div class="command-group sampling-rate-group">
      <label for="samplingRate">Sampling Rate (ms):</label>
      <input type="number" id="samplingRate" value="1000" min="100" step="100" />
    </div>
    <div class="command-group">
      <h3>Measurement & Recording</h3>
      <button id="startMeasure" disabled>Start Measurement</button>
      <button id="stopMeasure" disabled>Stop Measurement</button>
      <button id="startRecord" disabled>Start Recording</button>
      <button id="stopRecord" disabled>Stop Recording & Download</button>
    </div>
  </div>

  <h3>Log</h3>
  <pre id="log"></pre>

  <details open>
    <summary><strong>List of Useful Commands</strong></summary>
    <table>
      <thead>
        <tr>
          <th>Command</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>@</td>
          <td>Cancel (resets device)</td>
        </tr>
        <tr>
          <td>T</td>
          <td>Tare – sets the tare weight</td>
        </tr>
        <tr>
          <td>TI</td>
          <td>Tare Immediately</td>
        </tr>
        <tr>
          <td>Z</td>
          <td>Zero – set new zero after stable reading</td>
        </tr>
        <tr>
          <td>ZI</td>
          <td>Zero Immediately – set new zero regardless of stability</td>
        </tr>
        <tr>
          <td>S</td>
          <td>Send stable weight value</td>
        </tr>
        <tr>
          <td>SI</td>
          <td>Send immediate weight indication</td>
        </tr>
        <tr>
          <td>SIM</td>
          <td>Set mode of indication (Track, Peak, etc.)</td>
        </tr>
        <tr>
          <td>U</td>
          <td>Query/Set display and host unit</td>
        </tr>
      </tbody>
    </table>
  </details>

  <script>
    let port;
    let writer;
    let measurementInterval = null;
    let isRecording = false;
    let recordedData = []; // Stores {timestamp, data}

    // Save original button text values
    const originalTexts = {
      connect: "Connect to Scale",
      startMeasure: "Start Measurement",
      startRecord: "Start Recording"
    };

    const logEl = document.getElementById("log");
    const connectBtn = document.getElementById("connect");
    const disconnectBtn = document.getElementById("disconnect");
    const sendCmdBtn = document.getElementById("sendCmd");
    const commandInput = document.getElementById("commandInput");
    const startMeasureBtn = document.getElementById("startMeasure");
    const stopMeasureBtn = document.getElementById("stopMeasure");
    const startRecordBtn = document.getElementById("startRecord");
    const stopRecordBtn = document.getElementById("stopRecord");
    const currentReadingEl = document.getElementById("currentReading");
    const currentTimeEl = document.getElementById("currentTime");
    const samplingRateInput = document.getElementById("samplingRate");

    // Append a log message with timestamp.
    function appendLog(message) {
      const now = new Date().toLocaleTimeString();
      logEl.textContent += `[${now}] ${message}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    // Update the live read-out.
    function updateLiveReadout(reading) {
      const now = new Date().toISOString();
      currentReadingEl.textContent = reading;
      currentTimeEl.textContent = now;
    }

    // Connect to the serial port.
    async function connectSerial() {
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 9600, dataBits: 8, stopBits: 1, parity: "none" });
        appendLog("Port opened successfully");
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        sendCmdBtn.disabled = false;
        startMeasureBtn.disabled = false;
        startRecordBtn.disabled = false;
        writer = port.writable.getWriter();
        readLoop();
      } catch (err) {
        appendLog("Error: " + err);
      }
    }

    // Read loop with buffering; update read-out and record data.
    async function readLoop() {
      const decoder = new TextDecoder();
      const reader = port.readable.getReader();
      let buffer = "";
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            buffer += decoder.decode(value, { stream: true });
            let lines = buffer.split("\n");
            buffer = lines.pop();
            for (const line of lines) {
              const formatted = line.replace(/\r/g, "").trim();
              if (formatted !== "") {
                appendLog("Received: " + formatted);
                // Extract numeric measurement.
                const match = formatted.match(/(-?\d+(\.\d+)?)/);
                let measurement = match ? match[1] : formatted;
                updateLiveReadout(measurement);
                if (isRecording) {
                  const timestamp = new Date().toISOString();
                  recordedData.push({ timestamp: timestamp, data: measurement });
                }
              }
            }
          }
        }
      } catch (error) {
        appendLog("Read error: " + error);
      } finally {
        reader.releaseLock();
      }
    }

    // Send a command.
    async function sendCommand(cmd) {
      if (!writer) return;
      const fullCmd = cmd.trim() + "\r\n";
      const data = new TextEncoder().encode(fullCmd);
      await writer.write(data);
      appendLog("Sent: " + cmd);
    }

    // Start measurement with SI command at defined sampling rate.
    function startMeasurement() {
      if (measurementInterval !== null) return;
      const rate = parseInt(samplingRateInput.value) || 1000;
      measurementInterval = setInterval(() => {
        sendCommand("SI");
      }, rate);
      appendLog("Measurement started (polling every " + rate + " ms).");
      startMeasureBtn.disabled = true;
      stopMeasureBtn.disabled = false;
    }

    // Stop measurement.
    function stopMeasurement() {
      if (measurementInterval !== null) {
        clearInterval(measurementInterval);
        measurementInterval = null;
        appendLog("Measurement stopped.");
        startMeasureBtn.disabled = false;
        stopMeasureBtn.disabled = true;
      }
    }

    // Start recording.
    function startRecording() {
      if (isRecording) return;
      isRecording = true;
      recordedData = [];
      appendLog("Recording started.");
      startRecordBtn.disabled = true;
      stopRecordBtn.disabled = false;
    }

    // Stop recording and download CSV.
    function stopRecording() {
      if (!isRecording) return;
      isRecording = false;
      appendLog("Recording stopped.");
      startRecordBtn.disabled = false;
      stopRecordBtn.disabled = true;
      downloadRecording();
    }

    // Download CSV file from recorded data.
    function downloadRecording() {
      if (recordedData.length === 0) {
        appendLog("No data recorded.");
        return;
      }
      let csvContent = "data:text/csv;charset=utf-8,Timestamp,Mass [kg]\n";
      recordedData.forEach(item => {
        csvContent += `${item.timestamp},${item.data}\n`;
      });
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      const now = new Date().toISOString().replace(/[:\-]/g, "").replace(/\..+/, "");
      link.setAttribute("download", "scale_recording_" + now + ".csv");
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      appendLog("Recording downloaded as CSV.");
    }

    // Disconnect from the serial port.
    async function disconnectSerial() {
      try {
        stopMeasurement();
        stopRecording();
        if (port) {
          await port.close();
          appendLog("Port closed.");
        }
      } catch (e) {
        appendLog("Error closing port: " + e);
      } finally {
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        sendCmdBtn.disabled = true;
        startMeasureBtn.disabled = true;
        stopMeasureBtn.disabled = true;
        startRecordBtn.disabled = true;
        stopRecordBtn.disabled = true;
      }
    }

    // Event Listeners.
    connectBtn.addEventListener("click", connectSerial);
    disconnectBtn.addEventListener("click", disconnectSerial);
    sendCmdBtn.addEventListener("click", () => {
      const cmd = commandInput.value;
      if (cmd.length > 0) {
        sendCommand(cmd);
        commandInput.value = "";
      }
    });
    document.querySelectorAll(".cmd").forEach((button) => {
      button.addEventListener("click", () => {
        const cmd = button.getAttribute("data-cmd");
        sendCommand(cmd);
      });
    });
    commandInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        sendCmdBtn.click();
      }
    });
    startMeasureBtn.addEventListener("click", startMeasurement);
    stopMeasureBtn.addEventListener("click", stopMeasurement);
    startRecordBtn.addEventListener("click", startRecording);
    stopRecordBtn.addEventListener("click", stopRecording);
  </script>
</body>

</html>
